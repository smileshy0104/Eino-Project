# äº§å“æ–‡æ¡£AIåŠ©æ‰‹è®¾è®¡æ–¹æ¡ˆ

åŸºäº Eino æ¡†æ¶çš„æ™ºèƒ½æ–‡æ¡£æ£€ç´¢ç³»ç»Ÿ

---

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### ğŸ¯ é¡¹ç›®èƒŒæ™¯
åœ¨æ•æ·å¼€å‘æ¨¡å¼ä¸‹ï¼Œäº§å“éœ€æ±‚æ–‡æ¡£æ›´æ–°é¢‘ç¹ï¼Œå†å²ç‰ˆæœ¬ä¼—å¤šï¼Œå›¢é˜Ÿæˆå‘˜åœ¨æŸ¥æ‰¾ç‰¹å®šéœ€æ±‚ä¿¡æ¯æ—¶é¢ä¸´ä»¥ä¸‹ç—›ç‚¹ï¼š
- ğŸ“ æ–‡æ¡£åˆ†æ•£åœ¨ä¸åŒç‰ˆæœ¬å’Œæ–‡ä»¶å¤¹ä¸­
- ğŸ” å…³é”®è¯æœç´¢æ•ˆæœä¸ä½³ï¼Œæ— æ³•ç†è§£è¯­ä¹‰
- â° æŸ¥æ‰¾å†å²éœ€æ±‚è€—æ—¶è¿‡é•¿ï¼Œå½±å“å¼€å‘æ•ˆç‡
- ğŸ”„ æ–‡æ¡£æ›´æ–°åå›¢é˜ŸåŒæ­¥å›°éš¾

### ğŸ’¡ è§£å†³æ–¹æ¡ˆ
æ„å»ºä¸€ä¸ªåŸºäº Eino æ¡†æ¶çš„æ™ºèƒ½æ–‡æ¡£åŠ©æ‰‹ï¼Œå…·å¤‡ï¼š
- ğŸ¤– **æ™ºèƒ½é—®ç­”**ï¼šè‡ªç„¶è¯­è¨€æŸ¥è¯¢å†å²éœ€æ±‚
- ğŸ“š **è¯­ä¹‰æ£€ç´¢**ï¼šç†è§£éœ€æ±‚æ„å›¾ï¼Œç²¾å‡†åŒ¹é…æ–‡æ¡£
- ğŸ”„ **å®æ—¶åŒæ­¥**ï¼šè‡ªåŠ¨æ›´æ–°å‘é‡åº“ï¼Œä¿æŒæ•°æ®æœ€æ–°
- ğŸ“¢ **å›¢é˜Ÿé€šçŸ¥**ï¼šé€šè¿‡é£ä¹¦æœºå™¨äººæ¨é€æ–‡æ¡£å˜æ›´

---

## ğŸ¨ äº§å“åŠŸèƒ½è®¾è®¡

### æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

#### 1ï¸âƒ£ æ™ºèƒ½æ–‡æ¡£é—®ç­”
```
ç”¨æˆ·è¾“å…¥ï¼š
"ä¹‹å‰ç”¨æˆ·ç™»å½•åŠŸèƒ½çš„éªŒè¯ç æœ‰æ•ˆæœŸæ˜¯å¤šå°‘ï¼Ÿ"

AIåŠ©æ‰‹å›ç­”ï¼š
ğŸ“„ æ ¹æ® v2.3 äº§å“éœ€æ±‚æ–‡æ¡£ (2024-03-15)ï¼š
ç”¨æˆ·ç™»å½•éªŒè¯ç æœ‰æ•ˆæœŸè®¾å®šä¸º 5åˆ†é’Ÿ
ç›¸å…³æˆªå›¾ï¼š[éªŒè¯ç æµç¨‹å›¾]
è´Ÿè´£äººï¼š@å¼ ä¸‰ 
å…³è”éœ€æ±‚ï¼šPRD-001-ç”¨æˆ·è®¤è¯æ¨¡å—

ğŸ”— ç›¸å…³æ–‡æ¡£é“¾æ¥ï¼š
- ç”¨æˆ·è®¤è¯è¯¦ç»†è®¾è®¡ v2.3.pdf
- ç™»å½•æµç¨‹ä¼˜åŒ–æ–¹æ¡ˆ v1.2.docx
```

#### 2ï¸âƒ£ æ–‡æ¡£ç‰ˆæœ¬å¯¹æ¯”
```
ç”¨æˆ·è¾“å…¥ï¼š
"æ”¯ä»˜æ¨¡å—åœ¨æœ€è¿‘å‡ ä¸ªç‰ˆæœ¬æœ‰ä»€ä¹ˆå˜åŒ–ï¼Ÿ"

AIåŠ©æ‰‹å›ç­”ï¼š
ğŸ“ˆ æ”¯ä»˜æ¨¡å—ç‰ˆæœ¬å˜æ›´å†å²ï¼š

v3.1 (2024-04-10):
âœ… æ–°å¢å¾®ä¿¡æ”¯ä»˜
âœ… ä¼˜åŒ–æ”¯ä»˜è¶…æ—¶å¤„ç†

v3.0 (2024-03-20): 
âœ… æ”¯æŒæ”¯ä»˜å®
âŒ ç§»é™¤é“¶è¡Œå¡ç›´è¿

v2.8 (2024-02-15):
âœ… æ·»åŠ æ”¯ä»˜çŠ¶æ€å›è°ƒæœºåˆ¶
```

#### 3ï¸âƒ£ éœ€æ±‚å…³è”åˆ†æ
```
ç”¨æˆ·è¾“å…¥ï¼š
"è¿™ä¸ªåŠŸèƒ½ä¼šå½±å“åˆ°å“ªäº›å…¶ä»–æ¨¡å—ï¼Ÿ"

AIåŠ©æ‰‹åˆ†æï¼š
ğŸ”— å…³è”å½±å“åˆ†æï¼š

ç›´æ¥å½±å“ï¼š
- ç”¨æˆ·ä¸­å¿ƒæ¨¡å—ï¼ˆç”¨æˆ·çŠ¶æ€åŒæ­¥ï¼‰
- é€šçŸ¥æ¨¡å—ï¼ˆæ”¯ä»˜æˆåŠŸé€šçŸ¥ï¼‰

é—´æ¥å½±å“ï¼š
- è®¢å•æ¨¡å—ï¼ˆçŠ¶æ€æ›´æ–°é€»è¾‘ï¼‰
- æŠ¥è¡¨æ¨¡å—ï¼ˆè´¢åŠ¡ç»Ÿè®¡ï¼‰

å»ºè®®è¯„ä¼°ï¼š
âš ï¸  éœ€è¦åŒæ­¥æ›´æ–°ç”¨æˆ·ä¸­å¿ƒAPI
âš ï¸  é€šçŸ¥æ¨¡æ¿éœ€è¦æ·»åŠ æ–°å­—æ®µ
```

#### 4ï¸âƒ£ å®æ—¶æ–‡æ¡£ç›‘æ§
- ğŸ“ ç›‘æ§æŒ‡å®šç›®å½•çš„æ–‡æ¡£å˜æ›´
- ğŸ”„ è‡ªåŠ¨è§£ææ–°å¢/ä¿®æ”¹çš„æ–‡æ¡£
- ğŸ“Š å¢é‡æ›´æ–°å‘é‡åº“
- ğŸ“¢ é€šè¿‡é£ä¹¦æ¨é€å˜æ›´é€šçŸ¥

---

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é£ä¹¦ä¼ä¸šæ–‡æ¡£æº  â”‚    â”‚   Einoå¤„ç†å¼•æ“   â”‚    â”‚   ç”¨æˆ·äº¤äº’å±‚     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ é£ä¹¦æ–‡æ¡£API   â”‚â”€â”€â”€â–¶â”‚ â€¢ Transformer   â”‚â”€â”€â”€â–¶â”‚ â€¢ Webæ§åˆ¶å°     â”‚
â”‚ â€¢ å¤šç»´è¡¨æ ¼API   â”‚    â”‚ â€¢ Embedder      â”‚    â”‚ â€¢ é£ä¹¦æœºå™¨äºº     â”‚
â”‚ â€¢ çŸ¥è¯†åº“API     â”‚    â”‚ â€¢ Indexer       â”‚    â”‚ â€¢ é£ä¹¦å°ç¨‹åº     â”‚
â”‚ â€¢ Webhookç›‘å¬   â”‚    â”‚ â€¢ Retriever     â”‚    â”‚ â€¢ APIæ¥å£       â”‚
â”‚ â€¢ æƒé™åŒæ­¥      â”‚    â”‚ â€¢ ChatModel     â”‚    â”‚ â€¢ ç§»åŠ¨ç«¯åº”ç”¨     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   å­˜å‚¨å±‚        â”‚
                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚ â€¢ Milvuså‘é‡åº“  â”‚
                    â”‚ â€¢ MySQLå…ƒæ•°æ®   â”‚
                    â”‚ â€¢ Redisç¼“å­˜     â”‚
                    â”‚ â€¢ é£ä¹¦Tokenç¼“å­˜ â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒæŠ€æœ¯ç»„ä»¶

#### ğŸš€ é£ä¹¦æ–‡æ¡£é›†æˆå±‚
```go
package feishu

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "time"
    
    "github.com/cloudwego/eino/chain"
    "github.com/cloudwego/eino/compose"
)

// é£ä¹¦APIå®¢æˆ·ç«¯
type FeishuDocClient struct {
    AppID       string
    AppSecret   string
    AccessToken string
    BaseURL     string
    HTTPClient  *http.Client
}

// æ–‡æ¡£ä¿¡æ¯ç»“æ„ä½“
type DocumentInfo struct {
    Token      string    `json:"token"`
    Type       string    `json:"type"`
    Title      string    `json:"title"`
    URL        string    `json:"url"`
    Owner      string    `json:"owner"`
    CreateTime time.Time `json:"create_time"`
    UpdateTime time.Time `json:"update_time"`
}

// æ–‡æ¡£å†…å®¹ç»“æ„ä½“
type DocumentContent struct {
    Content  string                 `json:"content"`
    Metadata map[string]interface{} `json:"metadata"`
}

// åˆ›å»ºé£ä¹¦APIå®¢æˆ·ç«¯
func NewFeishuDocClient(appID, appSecret string) *FeishuDocClient {
    client := &FeishuDocClient{
        AppID:     appID,
        AppSecret: appSecret,
        BaseURL:   "https://open.feishu.cn",
        HTTPClient: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
    
    // è·å–è®¿é—®ä»¤ç‰Œ
    if err := client.refreshAccessToken(); err != nil {
        log.Printf("è·å–è®¿é—®ä»¤ç‰Œå¤±è´¥: %v", err)
    }
    
    return client
}

// è·å–æ‰€æœ‰å¯è®¿é—®çš„æ–‡æ¡£
func (c *FeishuDocClient) GetAllDocuments(ctx context.Context, folderToken string) ([]*DocumentInfo, error) {
    docTypes := []string{"doc", "sheet", "bitable", "wiki"}
    var allDocs []*DocumentInfo
    
    for _, docType := range docTypes {
        docs, err := c.fetchDocumentsByType(ctx, docType, folderToken)
        if err != nil {
            log.Printf("è·å– %s ç±»å‹æ–‡æ¡£å¤±è´¥: %v", docType, err)
            continue
        }
        allDocs = append(allDocs, docs...)
    }
    
    return allDocs, nil
}

// è·å–æ–‡æ¡£å…·ä½“å†…å®¹
func (c *FeishuDocClient) GetDocumentContent(ctx context.Context, docToken, docType string) (*DocumentContent, error) {
    switch docType {
    case "doc":
        return c.getDocContent(ctx, docToken)
    case "sheet":
        return c.getSheetContent(ctx, docToken)
    case "bitable":
        return c.getBitableContent(ctx, docToken)
    case "wiki":
        return c.getWikiContent(ctx, docToken)
    default:
        return nil, fmt.Errorf("ä¸æ”¯æŒçš„æ–‡æ¡£ç±»å‹: %s", docType)
    }
}

// è®¾ç½®Webhookç›‘å¬
func (c *FeishuDocClient) SetupWebhook(ctx context.Context, callbackURL string) error {
    events := []string{
        "drive.file.created_in_folder_v1",
        "drive.file.edit_v1", 
        "drive.file.title_updated_v1",
        "drive.file.trashed_v1",
    }
    
    for _, event := range events {
        if err := c.subscribeEvent(ctx, event, callbackURL); err != nil {
            log.Printf("è®¢é˜…äº‹ä»¶ %s å¤±è´¥: %v", event, err)
        }
    }
    
    return nil
}

// é£ä¹¦æ–‡æ¡£åŒæ­¥å™¨
type FeishuDocumentSyncer struct {
    client   *FeishuDocClient
    pipeline compose.Chain
}

// åˆ›å»ºæ–‡æ¡£åŒæ­¥å™¨
func NewFeishuDocumentSyncer(client *FeishuDocClient, pipeline compose.Chain) *FeishuDocumentSyncer {
    return &FeishuDocumentSyncer{
        client:   client,
        pipeline: pipeline,
    }
}

// å…¨é‡åŒæ­¥æ‰€æœ‰æ–‡æ¡£
func (s *FeishuDocumentSyncer) SyncAllDocuments(ctx context.Context) error {
    documents, err := s.client.GetAllDocuments(ctx, "")
    if err != nil {
        return fmt.Errorf("è·å–æ–‡æ¡£åˆ—è¡¨å¤±è´¥: %w", err)
    }
    
    for _, doc := range documents {
        if err := s.syncSingleDocument(ctx, doc); err != nil {
            log.Printf("åŒæ­¥æ–‡æ¡£å¤±è´¥ %s: %v", doc.Title, err)
            continue
        }
        log.Printf("åŒæ­¥æ–‡æ¡£æˆåŠŸ: %s", doc.Title)
    }
    
    return nil
}

// åŒæ­¥å•ä¸ªæ–‡æ¡£
func (s *FeishuDocumentSyncer) syncSingleDocument(ctx context.Context, doc *DocumentInfo) error {
    content, err := s.client.GetDocumentContent(ctx, doc.Token, doc.Type)
    if err != nil {
        return fmt.Errorf("è·å–æ–‡æ¡£å†…å®¹å¤±è´¥: %w", err)
    }
    
    // æ„å»ºå¤„ç†è¾“å…¥
    input := map[string]interface{}{
        "content": content.Content,
        "metadata": map[string]interface{}{
            "doc_token":   doc.Token,
            "doc_type":    doc.Type,
            "title":       doc.Title,
            "url":         doc.URL,
            "owner":       doc.Owner,
            "create_time": doc.CreateTime,
            "update_time": doc.UpdateTime,
            "source":      "feishu",
        },
    }
    
    // ä½¿ç”¨Einoå¤„ç†æ–‡æ¡£
    _, err = s.pipeline.Invoke(ctx, input)
    return err
}
```

#### ğŸ“„ æ–‡æ¡£å¤„ç†æµæ°´çº¿
```go
package pipeline

import (
    "context"
    
    "github.com/cloudwego/eino/chain"
    "github.com/cloudwego/eino/compose"
    "github.com/cloudwego/eino/components/document"
    "github.com/cloudwego/eino/components/embedding" 
    "github.com/cloudwego/eino/components/indexing"
)

// åˆ›å»ºä¸“é—¨é€‚é…é£ä¹¦æ–‡æ¡£çš„å¤„ç†æµæ°´çº¿
func NewFeishuDocumentPipeline() compose.Chain {
    // æ–‡æ¡£åŠ è½½å™¨
    docLoader := document.NewDocumentLoader(document.Config{
        ChunkSize:    512,
        ChunkOverlap: 50,
        PreserveStructure: true, // ä¿æŒé£ä¹¦æ–‡æ¡£ç»“æ„
    })
    
    // å†…å®¹åˆ†å‰²å™¨
    splitter := document.NewTextSplitter(document.SplitterConfig{
        ChunkSize:    512,
        ChunkOverlap: 50,
        Separators:   []string{"\n\n", "\n", "ã€‚", ".", " "},
    })
    
    // å‘é‡åµŒå…¥å™¨
    embedder := embedding.NewEmbedding(embedding.Config{
        Provider: "openai",
        Model:    "text-embedding-ada-002",
        APIKey:   os.Getenv("OPENAI_API_KEY"),
    })
    
    // å‘é‡ç´¢å¼•å™¨
    indexer := indexing.NewMilvusIndexer(indexing.MilvusConfig{
        Host:           "localhost:19530",
        CollectionName: "feishu_docs",
        Dimension:      1536,
        IndexType:      "IVF_FLAT",
        MetricType:     "L2",
    })
    
    // æ„å»ºå¤„ç†é“¾
    pipeline := compose.NewChain().
        AppendRunnable(docLoader).
        AppendRunnable(splitter).
        AppendRunnable(embedder).
        AppendRunnable(indexer)
    
    return pipeline
}

// é£ä¹¦æ–‡æ¡£å†…å®¹è§£æå™¨
type FeishuContentParser struct{}

func NewFeishuContentParser() *FeishuContentParser {
    return &FeishuContentParser{}
}

func (p *FeishuContentParser) Invoke(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error) {
    content, ok := input["content"].(string)
    if !ok {
        return input, fmt.Errorf("invalid content type")
    }
    
    docType, _ := input["metadata"].(map[string]interface{})["doc_type"].(string)
    
    var parsedContent string
    var err error
    
    switch docType {
    case "doc":
        parsedContent, err = p.parseFeishuDoc(content)
    case "sheet":
        parsedContent, err = p.parseFeishuSheet(content)
    case "bitable":
        parsedContent, err = p.parseFeishuBitable(content)
    case "wiki":
        parsedContent, err = p.parseFeishuWiki(content)
    default:
        parsedContent = content
    }
    
    if err != nil {
        return input, err
    }
    
    input["parsed_content"] = parsedContent
    return input, nil
}

// è§£æé£ä¹¦æ–‡æ¡£
func (p *FeishuContentParser) parseFeishuDoc(content string) (string, error) {
    // è§£æé£ä¹¦æ–‡æ¡£çš„ç‰¹æ®Šæ ¼å¼
    // å¤„ç†æ ‡é¢˜ã€æ®µè½ã€è¡¨æ ¼ã€ä»£ç å—ç­‰
    return content, nil
}

// æ”¯æŒçš„é£ä¹¦æ–‡æ¡£ç±»å‹
/*
- é£ä¹¦æ–‡æ¡£ (Doc) - å¯Œæ–‡æœ¬æ–‡æ¡£ï¼Œæ”¯æŒæ ‡é¢˜ã€æ®µè½ã€è¡¨æ ¼ã€å›¾ç‰‡ç­‰
- é£ä¹¦è¡¨æ ¼ (Sheet) - æ•°æ®è¡¨æ ¼ï¼Œè‡ªåŠ¨æå–å•å…ƒæ ¼å†…å®¹ 
- å¤šç»´è¡¨æ ¼ (Bitable) - ç»“æ„åŒ–æ•°æ®ï¼Œæ”¯æŒå­—æ®µç±»å‹è¯†åˆ«
- é£ä¹¦çŸ¥è¯†åº“ (Wiki) - çŸ¥è¯†åº“é¡µé¢ï¼Œä¿æŒé¡µé¢å±‚çº§ç»“æ„
- æ€ç»´å¯¼å›¾ (MindMap) - æµç¨‹å›¾è¡¨ï¼Œæå–èŠ‚ç‚¹å’Œå…³ç³»ä¿¡æ¯
*/
```

#### ğŸ” æ™ºèƒ½æ£€ç´¢å¼•æ“
```go
package retrieval

import (
    "context"
    
    "github.com/cloudwego/eino/compose"
    "github.com/cloudwego/eino/components/retriever"
    "github.com/cloudwego/eino/components/model"
    "github.com/cloudwego/eino/components/prompt"
)

// åˆ›å»ºRAGæ£€ç´¢é“¾
func NewDocumentQAChain() compose.Chain {
    // æŸ¥è¯¢åˆ†æå™¨
    queryAnalyzer := NewQueryAnalyzer()
    
    // è¯­ä¹‰æ£€ç´¢å™¨
    semanticRetriever := retriever.NewVectorRetriever(retriever.Config{
        Collection:      "feishu_docs",
        TopK:           5,
        ScoreThreshold: 0.7,
        SearchParams: map[string]interface{}{
            "nprobe": 10,
        },
    })
    
    // ç›¸å…³æ€§è¿‡æ»¤å™¨
    relevanceFilter := NewRelevanceFilter()
    
    // ä¸Šä¸‹æ–‡èšåˆå™¨
    contextAggregator := NewContextAggregator()
    
    // å¯¹è¯æ¨¡å‹
    chatModel := model.NewChatModel(model.Config{
        Provider:    "openai",
        Model:       "gpt-4",
        Temperature: 0.1,
        MaxTokens:   2000,
    })
    
    // æ„å»ºæ£€ç´¢é“¾
    chain := compose.NewChain().
        AppendRunnable(queryAnalyzer).
        AppendRunnable(semanticRetriever).
        AppendRunnable(relevanceFilter).
        AppendRunnable(contextAggregator).
        AppendRunnable(chatModel)
    
    return chain
}

// æŸ¥è¯¢åˆ†æå™¨
type QueryAnalyzer struct{}

func NewQueryAnalyzer() *QueryAnalyzer {
    return &QueryAnalyzer{}
}

func (q *QueryAnalyzer) Invoke(ctx context.Context, input map[string]interface{}) (map[string]interface{}, error) {
    query := input["query"].(string)
    
    // åˆ†ææŸ¥è¯¢æ„å›¾
    intent := q.analyzeIntent(query)
    
    // æå–å…³é”®è¯
    keywords := q.extractKeywords(query)
    
    // æ£€æµ‹æ—¶é—´èŒƒå›´
    timeRange := q.detectTimeRange(query)
    
    // è¯†åˆ«æ–‡æ¡£ç±»å‹åå¥½
    docTypePreference := q.detectDocTypePreference(query)
    
    input["analyzed_query"] = map[string]interface{}{
        "original_query":      query,
        "intent":              intent,
        "keywords":            keywords,
        "time_range":          timeRange,
        "doc_type_preference": docTypePreference,
    }
    
    return input, nil
}

// æ–‡æ¡£é—®ç­”ç³»ç»Ÿ
type DocumentQASystem struct {
    qaChain compose.Chain
}

func NewDocumentQASystem() *DocumentQASystem {
    return &DocumentQASystem{
        qaChain: NewDocumentQAChain(),
    }
}

func (qa *DocumentQASystem) Ask(ctx context.Context, question string) (string, error) {
    input := map[string]interface{}{
        "query": question,
    }
    
    result, err := qa.qaChain.Invoke(ctx, input)
    if err != nil {
        return "", err
    }
    
    answer, ok := result["answer"].(string)
    if !ok {
        return "", fmt.Errorf("invalid answer format")
    }
    
    return answer, nil
}

// æ£€ç´¢ç­–ç•¥é…ç½®
/*
æ£€ç´¢ç­–ç•¥ï¼š
- è¯­ä¹‰ç›¸ä¼¼åº¦æ£€ç´¢ï¼ˆä¸»è¦ï¼‰: ä½¿ç”¨å‘é‡ç›¸ä¼¼åº¦åŒ¹é…
- å…³é”®è¯åŒ¹é…æ£€ç´¢ï¼ˆè¾…åŠ©ï¼‰: è¡¥å……ä¼ ç»Ÿæ–‡æœ¬åŒ¹é…  
- æ—¶é—´èŒƒå›´è¿‡æ»¤: æ”¯æŒ"æœ€è¿‘ä¸€ä¸ªæœˆ"ç­‰æ—¶é—´æŸ¥è¯¢
- æ–‡æ¡£ç±»å‹è¿‡æ»¤: å¯æŒ‡å®šæŸ¥è¯¢ç‰¹å®šç±»å‹æ–‡æ¡£
- ä½œè€…/è´Ÿè´£äººè¿‡æ»¤: æŒ‰æ–‡æ¡£åˆ›å»ºè€…æˆ–è´Ÿè´£äººç­›é€‰
- æƒé™æ£€æŸ¥: ç¡®ä¿ç”¨æˆ·åªèƒ½è®¿é—®æœ‰æƒé™çš„æ–‡æ¡£
*/
```

#### ğŸ”„ é£ä¹¦å®æ—¶æ›´æ–°æœºåˆ¶
```go
package webhook

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
)

// é£ä¹¦äº‹ä»¶æ•°æ®ç»“æ„
type FeishuEvent struct {
    Schema string `json:"schema"`
    Header struct {
        EventID    string `json:"event_id"`
        EventType  string `json:"event_type"`
        CreateTime string `json:"create_time"`
        Token      string `json:"token"`
        AppID      string `json:"app_id"`
        TenantKey  string `json:"tenant_key"`
    } `json:"header"`
    Event map[string]interface{} `json:"event"`
}

// é£ä¹¦Webhookç›‘å¬å™¨
type FeishuWebhookListener struct {
    syncer   *FeishuDocumentSyncer
    notifier *FeishuNotifier
    server   *gin.Engine
}

func NewFeishuWebhookListener(syncer *FeishuDocumentSyncer, notifier *FeishuNotifier) *FeishuWebhookListener {
    listener := &FeishuWebhookListener{
        syncer:   syncer,
        notifier: notifier,
        server:   gin.Default(),
    }
    
    // è®¾ç½®è·¯ç”±
    listener.setupRoutes()
    
    return listener
}

func (l *FeishuWebhookListener) setupRoutes() {
    l.server.POST("/webhook/feishu", l.handleWebhook)
}

func (l *FeishuWebhookListener) handleWebhook(c *gin.Context) {
    var event FeishuEvent
    if err := c.ShouldBindJSON(&event); err != nil {
        log.Printf("è§£æwebhookæ•°æ®å¤±è´¥: %v", err)
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // éªŒè¯äº‹ä»¶åˆæ³•æ€§
    if !l.validateEvent(&event) {
        log.Printf("äº‹ä»¶éªŒè¯å¤±è´¥: %s", event.Header.EventID)
        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid event"})
        return
    }
    
    // å¤„ç†æ–‡æ¡£äº‹ä»¶
    go l.handleDocumentEvent(context.Background(), &event)
    
    c.JSON(http.StatusOK, gin.H{"challenge": event.Event["challenge"]})
}

func (l *FeishuWebhookListener) handleDocumentEvent(ctx context.Context, event *FeishuEvent) {
    switch event.Header.EventType {
    case "drive.file.edit_v1", "drive.file.title_updated_v1":
        l.handleDocumentUpdate(ctx, event)
    case "drive.file.created_in_folder_v1":
        l.handleDocumentCreate(ctx, event)
    case "drive.file.trashed_v1":
        l.handleDocumentDelete(ctx, event)
    default:
        log.Printf("æœªå¤„ç†çš„äº‹ä»¶ç±»å‹: %s", event.Header.EventType)
    }
}

func (l *FeishuWebhookListener) handleDocumentUpdate(ctx context.Context, event *FeishuEvent) {
    docToken, ok := event.Event["file_token"].(string)
    if !ok {
        log.Printf("æ— æ•ˆçš„æ–‡æ¡£token")
        return
    }
    
    docType, _ := event.Event["file_type"].(string)
    
    // é‡æ–°åŒæ­¥æ–‡æ¡£
    doc := &DocumentInfo{
        Token: docToken,
        Type:  docType,
    }
    
    if err := l.syncer.syncSingleDocument(ctx, doc); err != nil {
        log.Printf("åŒæ­¥æ–‡æ¡£å¤±è´¥ %s: %v", docToken, err)
        return
    }
    
    // å‘é€æ›´æ–°é€šçŸ¥
    l.sendUpdateNotification(event)
}

func (l *FeishuWebhookListener) handleDocumentCreate(ctx context.Context, event *FeishuEvent) {
    // å¤„ç†æ–°æ–‡æ¡£åˆ›å»º
    l.handleDocumentUpdate(ctx, event)
}

func (l *FeishuWebhookListener) handleDocumentDelete(ctx context.Context, event *FeishuEvent) {
    docToken, ok := event.Event["file_token"].(string)
    if !ok {
        return
    }
    
    // ä»å‘é‡åº“ä¸­åˆ é™¤ç›¸å…³æ–‡æ¡£
    // è¿™é‡Œéœ€è¦å®ç°åˆ é™¤é€»è¾‘
    log.Printf("æ–‡æ¡£å·²åˆ é™¤: %s", docToken)
}

func (l *FeishuWebhookListener) sendUpdateNotification(event *FeishuEvent) {
    docInfo := map[string]interface{}{
        "title":       event.Event["file_name"],
        "update_time": time.Now().Format("2006-01-02 15:04:05"),
        "operator":    event.Event["operator_id"],
        "doc_token":   event.Event["file_token"],
        "doc_url":     fmt.Sprintf("https://bytedance.feishu.cn/docs/%s", event.Event["file_token"]),
    }
    
    l.notifier.SendDocumentUpdateNotification(docInfo)
}

func (l *FeishuWebhookListener) Start(addr string) error {
    log.Printf("å¯åŠ¨Webhookç›‘å¬å™¨ï¼Œåœ°å€: %s", addr)
    return l.server.Run(addr)
}

// æƒé™åŒæ­¥å™¨
type FeishuPermissionSyncer struct {
    client *FeishuDocClient
}

func NewFeishuPermissionSyncer(client *FeishuDocClient) *FeishuPermissionSyncer {
    return &FeishuPermissionSyncer{
        client: client,
    }
}

type DocumentPermission struct {
    DocToken  string    `json:"doc_token"`
    Viewers   []string  `json:"viewers"`
    Editors   []string  `json:"editors"`
    Owners    []string  `json:"owners"`
    UpdatedAt time.Time `json:"updated_at"`
}

func (s *FeishuPermissionSyncer) SyncDocumentPermissions(ctx context.Context, docToken string) (*DocumentPermission, error) {
    permissions, err := s.client.getDocumentPermissions(ctx, docToken)
    if err != nil {
        return nil, fmt.Errorf("è·å–æ–‡æ¡£æƒé™å¤±è´¥: %w", err)
    }
    
    permissionCache := &DocumentPermission{
        DocToken:  docToken,
        Viewers:   permissions["viewers"].([]string),
        Editors:   permissions["editors"].([]string),
        Owners:    permissions["owners"].([]string),
        UpdatedAt: time.Now(),
    }
    
    // ä¿å­˜åˆ°æœ¬åœ°ç¼“å­˜
    if err := s.savePermissionCache(permissionCache); err != nil {
        log.Printf("ä¿å­˜æƒé™ç¼“å­˜å¤±è´¥: %v", err)
    }
    
    return permissionCache, nil
}

func (s *FeishuPermissionSyncer) savePermissionCache(permission *DocumentPermission) error {
    // å®ç°æƒé™ç¼“å­˜ä¿å­˜é€»è¾‘
    // å¯ä»¥ä¿å­˜åˆ° Redis æˆ–æ•°æ®åº“ä¸­
    return nil
}
```

---

## ğŸ› ï¸ å®æ–½æ–¹æ¡ˆ

### Phase 1: æ ¸å¿ƒåŠŸèƒ½å¼€å‘ï¼ˆ4å‘¨ï¼‰

**Week 1-2: åŸºç¡€æ¶æ„æ­å»º**
- [x] Einoç¯å¢ƒé…ç½®
- [x] Milvuså‘é‡æ•°æ®åº“éƒ¨ç½²
- [x] æ–‡æ¡£å¤„ç†æµæ°´çº¿å¼€å‘
- [x] åŸºç¡€Webç•Œé¢

**Week 3-4: æ™ºèƒ½æ£€ç´¢åŠŸèƒ½**
- [x] RAGæ£€ç´¢é“¾å®ç°
- [x] å¤šæ¨¡æ€æ–‡æ¡£è§£æ
- [x] åŸºç¡€é—®ç­”åŠŸèƒ½
- [x] æ£€ç´¢ç»“æœä¼˜åŒ–

### Phase 2: é«˜çº§åŠŸèƒ½å¼€å‘ï¼ˆ3å‘¨ï¼‰

**Week 5-6: å®æ—¶æ›´æ–°æœºåˆ¶**
- [x] æ–‡ä»¶ç›‘æ§ç³»ç»Ÿ
- [x] å¢é‡æ›´æ–°é€»è¾‘
- [x] ç‰ˆæœ¬ç®¡ç†åŠŸèƒ½

**Week 7: é£ä¹¦é›†æˆ**
- [x] é£ä¹¦æœºå™¨äººå¼€å‘
- [x] æ¶ˆæ¯æ¨é€åŠŸèƒ½
- [x] ç”¨æˆ·æƒé™ç®¡ç†

### Phase 3: ä¼˜åŒ–ä¸éƒ¨ç½²ï¼ˆ2å‘¨ï¼‰

**Week 8: ç³»ç»Ÿä¼˜åŒ–**
- [x] æ€§èƒ½è°ƒä¼˜
- [x] ç¼“å­˜ç­–ç•¥ä¼˜åŒ–
- [x] é”™è¯¯å¤„ç†å®Œå–„

**Week 9: ä¸Šçº¿éƒ¨ç½²**
- [x] ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
- [x] ç”¨æˆ·åŸ¹è®­
- [x] è¿ç»´ç›‘æ§

---

## ğŸ’» æŠ€æœ¯å®ç°è¯¦è§£

### å®Œæ•´åº”ç”¨ç¤ºä¾‹

```go
package main

import (
    "context"
    "log"
    "os"
    "os/signal"
    "syscall"
    
    "github.com/gin-gonic/gin"
    "your-project/pkg/feishu"
    "your-project/pkg/pipeline"
    "your-project/pkg/retrieval"
    "your-project/pkg/webhook"
)

func main() {
    // è¯»å–é…ç½®
    config := loadConfig()
    
    // åˆå§‹åŒ–é£ä¹¦å®¢æˆ·ç«¯
    feishuClient := feishu.NewFeishuDocClient(
        config.Feishu.AppID,
        config.Feishu.AppSecret,
    )
    
    // åˆ›å»ºæ–‡æ¡£å¤„ç†æµæ°´çº¿
    docPipeline := pipeline.NewFeishuDocumentPipeline()
    
    // åˆ›å»ºæ–‡æ¡£åŒæ­¥å™¨
    syncer := feishu.NewFeishuDocumentSyncer(feishuClient, docPipeline)
    
    // åˆ›å»ºé—®ç­”ç³»ç»Ÿ
    qaSystem := retrieval.NewDocumentQASystem()
    
    // åˆ›å»ºé€šçŸ¥å™¨
    notifier := feishu.NewFeishuNotifier(config.Feishu.Bot.WebhookURL)
    
    // åˆ›å»ºWebhookç›‘å¬å™¨
    webhookListener := webhook.NewFeishuWebhookListener(syncer, notifier)
    
    // è®¾ç½®APIè·¯ç”±
    router := gin.Default()
    setupAPIRoutes(router, qaSystem)
    
    // å¯åŠ¨æœåŠ¡
    go func() {
        log.Println("å¯åŠ¨APIæœåŠ¡å™¨ :8080")
        if err := router.Run(":8080"); err != nil {
            log.Fatalf("APIæœåŠ¡å™¨å¯åŠ¨å¤±è´¥: %v", err)
        }
    }()
    
    go func() {
        log.Println("å¯åŠ¨Webhookç›‘å¬å™¨ :8081")
        if err := webhookListener.Start(":8081"); err != nil {
            log.Fatalf("Webhookç›‘å¬å™¨å¯åŠ¨å¤±è´¥: %v", err)
        }
    }()
    
    // é¦–æ¬¡å…¨é‡åŒæ­¥
    log.Println("å¼€å§‹å…¨é‡åŒæ­¥æ–‡æ¡£...")
    if err := syncer.SyncAllDocuments(context.Background()); err != nil {
        log.Printf("å…¨é‡åŒæ­¥å¤±è´¥: %v", err)
    } else {
        log.Println("å…¨é‡åŒæ­¥å®Œæˆ")
    }
    
    // è®¾ç½®Webhook
    if err := feishuClient.SetupWebhook(context.Background(), "http://your-domain.com:8081/webhook/feishu"); err != nil {
        log.Printf("è®¾ç½®Webhookå¤±è´¥: %v", err)
    }
    
    // ç­‰å¾…é€€å‡ºä¿¡å·
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("æœåŠ¡å™¨æ­£åœ¨å…³é—­...")
}

func setupAPIRoutes(router *gin.Engine, qaSystem *retrieval.DocumentQASystem) {
    api := router.Group("/api/v1")
    
    // æ–‡æ¡£é—®ç­”æ¥å£
    api.POST("/ask", func(c *gin.Context) {
        var request struct {
            Question string `json:"question" binding:"required"`
        }
        
        if err := c.ShouldBindJSON(&request); err != nil {
            c.JSON(400, gin.H{"error": err.Error()})
            return
        }
        
        answer, err := qaSystem.Ask(c.Request.Context(), request.Question)
        if err != nil {
            c.JSON(500, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(200, gin.H{
            "answer": answer,
            "timestamp": time.Now(),
        })
    })
    
    // å¥åº·æ£€æŸ¥æ¥å£
    api.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "ok"})
    })
}

type Config struct {
    Feishu struct {
        AppID     string `yaml:"app_id"`
        AppSecret string `yaml:"app_secret"`
        Bot       struct {
            WebhookURL string `yaml:"webhook_url"`
        } `yaml:"bot"`
    } `yaml:"feishu"`
}

func loadConfig() *Config {
    // å®ç°é…ç½®æ–‡ä»¶åŠ è½½é€»è¾‘
    return &Config{}
}
```

### é¡¹ç›®ç»“æ„

```
feishu-doc-ai/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go                 # ä¸»ç¨‹åºå…¥å£
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ feishu/                     # é£ä¹¦APIé›†æˆ
â”‚   â”‚   â”œâ”€â”€ client.go              # é£ä¹¦APIå®¢æˆ·ç«¯  
â”‚   â”‚   â”œâ”€â”€ syncer.go              # æ–‡æ¡£åŒæ­¥å™¨
â”‚   â”‚   â””â”€â”€ notifier.go            # é£ä¹¦é€šçŸ¥å™¨
â”‚   â”œâ”€â”€ pipeline/                   # æ–‡æ¡£å¤„ç†æµæ°´çº¿
â”‚   â”‚   â”œâ”€â”€ processor.go           # æ–‡æ¡£å¤„ç†å™¨
â”‚   â”‚   â””â”€â”€ parser.go              # å†…å®¹è§£æå™¨
â”‚   â”œâ”€â”€ retrieval/                  # æ£€ç´¢å’Œé—®ç­”
â”‚   â”‚   â”œâ”€â”€ qa.go                  # é—®ç­”ç³»ç»Ÿ
â”‚   â”‚   â””â”€â”€ analyzer.go            # æŸ¥è¯¢åˆ†æå™¨
â”‚   â”œâ”€â”€ webhook/                    # Webhookå¤„ç†
â”‚   â”‚   â”œâ”€â”€ listener.go            # äº‹ä»¶ç›‘å¬å™¨
â”‚   â”‚   â””â”€â”€ handler.go             # äº‹ä»¶å¤„ç†å™¨
â”‚   â””â”€â”€ config/                     # é…ç½®ç®¡ç†
â”‚       â””â”€â”€ config.go              # é…ç½®ç»“æ„ä½“
â”œâ”€â”€ configs/
â”‚   â””â”€â”€ config.yaml                 # é…ç½®æ–‡ä»¶
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ Dockerfile                  # Dockeræ„å»ºæ–‡ä»¶
â”‚   â””â”€â”€ docker-compose.yml         # å®¹å™¨ç¼–æ’
â”œâ”€â”€ docs/                           # é¡¹ç›®æ–‡æ¡£
â”œâ”€â”€ go.mod                          # Goæ¨¡å—æ–‡ä»¶
â””â”€â”€ go.sum                          # ä¾èµ–ç‰ˆæœ¬é”å®š
```

### Goä¾èµ–ç®¡ç†

```go
// go.mod
module feishu-doc-ai

go 1.21

require (
    github.com/cloudwego/eino v0.0.10
    github.com/gin-gonic/gin v1.9.1
    github.com/go-redis/redis/v8 v8.11.5
    github.com/milvus-io/milvus-sdk-go/v2 v2.3.1
    github.com/spf13/viper v1.16.0
    github.com/stretchr/testify v1.8.4
    gopkg.in/yaml.v3 v3.0.1
)
```

### æ ¸å¿ƒé…ç½®æ–‡ä»¶

```yaml
# configs/config.yaml
app:
  name: "é£ä¹¦æ–‡æ¡£AIåŠ©æ‰‹"
  version: "1.0.0"
  host: "0.0.0.0"
  port: 8080
  webhook_port: 8081

# é£ä¹¦é…ç½® (å·²åœ¨å‰é¢æä¾›)
feishu:
  app_id: "${FEISHU_APP_ID}"
  app_secret: "${FEISHU_APP_SECRET}"
  # ... (å…¶ä»–é…ç½®)

# Einoæ¡†æ¶é…ç½®
eino:
  models:
    embedding:
      provider: "openai"
      model: "text-embedding-ada-002"
    chat:
      provider: "openai" 
      model: "gpt-4"
      
  # Milvuså‘é‡æ•°æ®åº“
  milvus:
    host: "localhost"
    port: 19530
    collection: "feishu_docs"
    dimension: 1536
    
  # æ–‡æ¡£å¤„ç†é…ç½®
  document:
    chunk_size: 512
    chunk_overlap: 50
    batch_size: 100
```

---

## ğŸš€ éƒ¨ç½²æ–¹æ¡ˆ

### åŸºç¡€è®¾æ–½éœ€æ±‚

**æœåŠ¡å™¨é…ç½®:**
- **CPU**: 4æ ¸å¿ƒä»¥ä¸Š
- **å†…å­˜**: 16GBä»¥ä¸Š  
- **å­˜å‚¨**: 500GB SSD
- **ç½‘ç»œ**: 10Mbpsä»¥ä¸Šå¸¦å®½

**ä¾èµ–æœåŠ¡:**
```yaml
version: '3.8'
services:
  # Milvuså‘é‡æ•°æ®åº“
  milvus:
    image: milvusdb/milvus:latest
    ports:
      - "19530:19530"
    volumes:
      - milvus_data:/var/lib/milvus
    environment:
      - MILVUS_CONFIG_PATH=/milvus/configs/milvus.yaml
  
  # MySQLå…ƒæ•°æ®å­˜å‚¨
  mysql:
    image: mysql:8.0
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=your_password
      - MYSQL_DATABASE=document_ai
    volumes:
      - mysql_data:/var/lib/mysql
  
  # Redisç¼“å­˜
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
  
  # åº”ç”¨ä¸»æœåŠ¡
  document-ai:
    build: .
    ports:
      - "8080:8080"
    depends_on:
      - milvus
      - mysql
      - redis
    environment:
      - MILVUS_HOST=milvus
      - MYSQL_HOST=mysql
      - REDIS_HOST=redis
    volumes:
      - ./documents:/app/documents
      - ./logs:/app/logs

volumes:
  milvus_data:
  mysql_data:
  redis_data:
```

### ç¯å¢ƒé…ç½®

**åº”ç”¨é…ç½®æ–‡ä»¶ (`config.yaml`):**
```yaml
# åº”ç”¨é…ç½®
app:
  name: "äº§å“æ–‡æ¡£AIåŠ©æ‰‹"
  version: "1.0.0"
  host: "0.0.0.0"
  port: 8080
  debug: false

# æ•°æ®åº“é…ç½®
database:
  milvus:
    host: "localhost"
    port: 19530
    collection_name: "product_docs"
    
  mysql:
    host: "localhost"
    port: 3306
    username: "root"
    password: "your_password"
    database: "document_ai"
    
  redis:
    host: "localhost"
    port: 6379
    password: ""
    db: 0

# AIæ¨¡å‹é…ç½®
models:
  embedding:
    provider: "openai"
    model: "text-embedding-ada-002"
    api_key: "${OPENAI_API_KEY}"
    
  chat:
    provider: "openai"
    model: "gpt-4"
    api_key: "${OPENAI_API_KEY}"
    temperature: 0.1
    max_tokens: 2000

# æ–‡æ¡£ç›‘æ§é…ç½®
monitoring:
  watch_paths:
    - "/data/product_docs"
    - "/data/requirements"
  file_types: [".docx", ".pdf", ".md", ".txt"]
  update_delay: 5  # ç§’

# é£ä¹¦é›†æˆé…ç½®
feishu:
  # é£ä¹¦åº”ç”¨é…ç½®
  app_id: "${FEISHU_APP_ID}"
  app_secret: "${FEISHU_APP_SECRET}"
  
  # APIé…ç½®
  api_base_url: "https://open.feishu.cn"
  
  # æœºå™¨äººé…ç½®
  bot:
    webhook_url: "${FEISHU_WEBHOOK_URL}"
    encrypt_key: "${FEISHU_ENCRYPT_KEY}"
    verification_token: "${FEISHU_VERIFICATION_TOKEN}"
  
  # æ–‡æ¡£åŒæ­¥é…ç½®
  sync:
    batch_size: 50  # æ‰¹é‡åŒæ­¥æ–‡æ¡£æ•°é‡
    rate_limit: 100  # æ¯åˆ†é’ŸAPIè°ƒç”¨é™åˆ¶
    retry_times: 3   # å¤±è´¥é‡è¯•æ¬¡æ•°
    sync_interval: 3600  # å…¨é‡åŒæ­¥é—´éš”(ç§’)
    
  # ç›‘å¬çš„æ–‡æ¡£æ–‡ä»¶å¤¹
  watch_folders:
    - "äº§å“éœ€æ±‚æ–‡æ¡£"
    - "æŠ€æœ¯è®¾è®¡æ–‡æ¡£" 
    - "é¡¹ç›®ç®¡ç†æ–‡æ¡£"
    - "ç”¨æˆ·ç ”ç©¶æŠ¥å‘Š"
  
  # Webhookäº‹ä»¶è®¢é˜…
  events:
    - "drive.file.created_in_folder_v1"
    - "drive.file.edit_v1"
    - "drive.file.title_updated_v1"
    - "drive.file.trashed_v1"

# æ—¥å¿—é…ç½®
logging:
  level: "INFO"
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  file: "/app/logs/app.log"
  max_size: "100MB"
  backup_count: 5
```

---

## ğŸ” é£ä¹¦APIæƒé™é…ç½®

### å¿…éœ€çš„APIæƒé™

**åº”ç”¨æƒé™ç”³è¯·æ¸…å•:**
```yaml
# æ–‡æ¡£ç›¸å…³æƒé™
document_permissions:
  - "drive:drive"              # äº‘æ–‡æ¡£åŸºç¡€æƒé™
  - "docs:doc"                # é£ä¹¦æ–‡æ¡£æƒé™  
  - "sheets:spreadsheet"      # é£ä¹¦è¡¨æ ¼æƒé™
  - "wiki:wiki"               # é£ä¹¦çŸ¥è¯†åº“æƒé™
  - "bitable:app"             # å¤šç»´è¡¨æ ¼æƒé™

# ç”¨æˆ·å’Œç»„ç»‡æƒé™
user_permissions:
  - "contact:user.base:readonly"     # è¯»å–ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
  - "contact:department.base:readonly" # è¯»å–éƒ¨é—¨ä¿¡æ¯

# æœºå™¨äººæƒé™
bot_permissions:
  - "im:message"              # å‘é€æ¶ˆæ¯æƒé™
  - "im:message.group_at_msg" # ç¾¤èŠ@æ¶ˆæ¯æƒé™
```

### å®‰å…¨é…ç½®è¦ç‚¹

**1. Tokenå®‰å…¨ç®¡ç†**
- ä½¿ç”¨ç¯å¢ƒå˜é‡å­˜å‚¨æ•æ„Ÿä¿¡æ¯
- å®šæœŸåˆ·æ–°Access Token
- å®ç°Tokenå¤±æ•ˆè‡ªåŠ¨é‡è¯•æœºåˆ¶

**2. æƒé™æœ€å°åŒ–åŸåˆ™**
- åªç”³è¯·å¿…éœ€çš„æœ€å°æƒé™
- æŒ‰ç”¨æˆ·è§’è‰²æ§åˆ¶æ–‡æ¡£è®¿é—®
- å®šæœŸå®¡è®¡æƒé™ä½¿ç”¨æƒ…å†µ

**3. æ•°æ®å®‰å…¨**
- æœ¬åœ°å‘é‡åº“åŠ å¯†å­˜å‚¨
- APIè°ƒç”¨æ—¥å¿—è„±æ•å¤„ç†
- å®ç°æ•°æ®å¤‡ä»½å’Œæ¢å¤æœºåˆ¶

### é£ä¹¦åº”ç”¨åˆ›å»ºæ­¥éª¤

**Step 1: åˆ›å»ºé£ä¹¦ä¼ä¸šåº”ç”¨**
```bash
1. è®¿é—® https://open.feishu.cn/app
2. ç‚¹å‡»"åˆ›å»ºä¼ä¸šè‡ªå»ºåº”ç”¨"
3. å¡«å†™åº”ç”¨åç§°ï¼š"äº§å“æ–‡æ¡£AIåŠ©æ‰‹"
4. é€‰æ‹©åº”ç”¨ç±»å‹ï¼š"æœºå™¨äºº"
5. ä¸Šä¼ åº”ç”¨å›¾æ ‡å’Œæè¿°
```

**Step 2: é…ç½®æƒé™èŒƒå›´**
```bash
1. è¿›å…¥"æƒé™ç®¡ç†"é¡µé¢
2. æŒ‰ç…§ä¸Šè¿°æƒé™æ¸…å•ç”³è¯·æƒé™
3. æäº¤å®¡æ ¸ï¼ˆé€šå¸¸éœ€è¦1-3ä¸ªå·¥ä½œæ—¥ï¼‰
4. è·å¾—ç®¡ç†å‘˜æ‰¹å‡†åç”Ÿæ•ˆ
```

**Step 3: è·å–åº”ç”¨å‡­è¯**
```bash
1. è®°å½• App ID å’Œ App Secret
2. é…ç½®æœåŠ¡å™¨å›è°ƒåœ°å€
3. è®¾ç½®äº‹ä»¶è®¢é˜…Webhook
4. æµ‹è¯•APIè°ƒç”¨æ˜¯å¦æ­£å¸¸
```

---

## ğŸ“Š æ•ˆæœé¢„æœŸä¸æˆæœ¬åˆ†æ

### é¢„æœŸæ•ˆæœ

**æ•ˆç‡æå‡:**
- ğŸ“ˆ æ–‡æ¡£æŸ¥æ‰¾æ—¶é—´å‡å°‘ **80%** (ä»å¹³å‡30åˆ†é’Ÿé™è‡³5åˆ†é’Ÿ)
- ğŸ¯ æŸ¥è¯¢å‡†ç¡®ç‡è¾¾åˆ° **90%ä»¥ä¸Š**
- ğŸ“± æ”¯æŒç§»åŠ¨ç«¯æŸ¥è¯¢ï¼Œéšæ—¶éšåœ°è®¿é—®
- ğŸ”„ æ–‡æ¡£æ›´æ–°é€šçŸ¥åŠæ—¶ç‡ **100%**

**ç”¨æˆ·ä½“éªŒ:**
- ğŸ’¬ è‡ªç„¶è¯­è¨€æŸ¥è¯¢ï¼Œæ— éœ€è®°å¿†å…³é”®è¯
- ğŸ“± å¤šç«¯è®¿é—®ï¼ŒWeb + ç§»åŠ¨ç«¯ + é£ä¹¦
- ğŸ” æ™ºèƒ½æ¨èç›¸å…³æ–‡æ¡£
- ğŸ“Š å¯è§†åŒ–çš„æŸ¥è¯¢ç»“æœå±•ç¤º

### æˆæœ¬åˆ†æ

**å¼€å‘æˆæœ¬:**
```
äººåŠ›æˆæœ¬ï¼š
- åç«¯å¼€å‘å·¥ç¨‹å¸ˆ 1äºº Ã— 2ä¸ªæœˆ = 40K
- å‰ç«¯å¼€å‘å·¥ç¨‹å¸ˆ 1äºº Ã— 1ä¸ªæœˆ = 20K  
- äº§å“ç»ç† 0.5äºº Ã— 2ä¸ªæœˆ = 15K
- æµ‹è¯•å·¥ç¨‹å¸ˆ 0.5äºº Ã— 1ä¸ªæœˆ = 8K
å°è®¡ï¼š83K

æŠ€æœ¯æˆæœ¬ï¼š
- OpenAI APIè´¹ç”¨ï¼šçº¦500å…ƒ/æœˆ
- æœåŠ¡å™¨è´¹ç”¨ï¼šçº¦2000å…ƒ/æœˆ
- å…¶ä»–å·¥å…·è´¹ç”¨ï¼šçº¦300å…ƒ/æœˆ
å°è®¡ï¼š2800å…ƒ/æœˆ
```

**æŠ•èµ„å›æŠ¥ç‡(ROI):**
```
æ—¶é—´æˆæœ¬èŠ‚çœï¼š
- 20äººå›¢é˜Ÿ Ã— 2å°æ—¶/å‘¨ Ã— 4å‘¨/æœˆ Ã— 500å…ƒ/å°æ—¶ = 80K/æœˆ

æ•ˆç‡æå‡ä»·å€¼ï¼š
- å‡å°‘é‡å¤å·¥ä½œï¼Œæå‡å†³ç­–é€Ÿåº¦
- é¢„ä¼°ä»·å€¼ï¼š20K/æœˆ

æ€»æ”¶ç›Šï¼š100K/æœˆ
æŠ•èµ„å›æ”¶æœŸï¼šçº¦1ä¸ªæœˆ
å¹´åŒ–ROIï¼šçº¦1300%
```

---

## ğŸ”„ åç»­æ‰©å±•è§„åˆ’

### Phase 4: æ™ºèƒ½åŒ–å¢å¼ºï¼ˆæœªæ¥6ä¸ªæœˆï¼‰

**å¤šæ¨¡æ€æ”¯æŒ:**
- ğŸ“· å›¾ç‰‡è¯†åˆ«å’Œç†è§£ï¼ˆæµç¨‹å›¾ã€åŸå‹å›¾ï¼‰
- ğŸ¥ è§†é¢‘å†…å®¹åˆ†æï¼ˆäº§å“æ¼”ç¤ºè§†é¢‘ï¼‰
- ğŸ“Š è¡¨æ ¼æ•°æ®æ™ºèƒ½è§£æ

**æ™ºèƒ½å†™ä½œåŠ©æ‰‹:**
- ğŸ“ åŸºäºå†å²æ–‡æ¡£è‡ªåŠ¨ç”Ÿæˆæ–°éœ€æ±‚æ–‡æ¡£
- ğŸ”„ éœ€æ±‚å˜æ›´å½±å“åˆ†æ
- ğŸ“‹ è‡ªåŠ¨ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹

**å›¢é˜Ÿåä½œå¢å¼º:**
- ğŸ’¬ é›†æˆé’‰é’‰ã€ä¼ä¸šå¾®ä¿¡
- ğŸ“… ä¸é¡¹ç›®ç®¡ç†å·¥å…·é›†æˆï¼ˆJiraã€Trelloï¼‰
- ğŸ”” æ™ºèƒ½æé†’å’Œä»»åŠ¡åˆ†é…

### Phase 5: ç”Ÿæ€åŒ–é›†æˆï¼ˆæœªæ¥12ä¸ªæœˆï¼‰

**å¼€å‘å·¥å…·é›†æˆ:**
- ğŸ”§ ä¸IDEé›†æˆï¼ˆVS Codeæ’ä»¶ï¼‰
- ğŸ“± ç§»åŠ¨ç«¯åŸç”Ÿåº”ç”¨
- ğŸŒ æµè§ˆå™¨æ’ä»¶

**æ•°æ®æ´å¯Ÿ:**
- ğŸ“ˆ æ–‡æ¡£ä½¿ç”¨æƒ…å†µåˆ†æ
- ğŸ¯ çƒ­é—¨éœ€æ±‚è¯†åˆ«
- ğŸ“Š å›¢é˜ŸçŸ¥è¯†å›¾è°±æ„å»º

---

## âœ… ç»“è®ºä¸å»ºè®®

### é¡¹ç›®å¯è¡Œæ€§è¯„ä¼°: â­â­â­â­â­

**æŠ€æœ¯å¯è¡Œæ€§:** ğŸŸ¢ **é«˜**
- Einoæ¡†æ¶æˆç†Ÿç¨³å®šï¼Œç¤¾åŒºæ´»è·ƒ
- RAGæŠ€æœ¯æ–¹æ¡ˆç»è¿‡éªŒè¯
- æ‰€éœ€æŠ€æœ¯æ ˆå›¢é˜Ÿå·²æŒæ¡

**å•†ä¸šä»·å€¼:** ğŸŸ¢ **é«˜**
- ç›´æ¥è§£å†³å›¢é˜Ÿç—›ç‚¹
- ROIæ˜¾è‘—ï¼ŒæŠ•èµ„å›æ”¶æœŸçŸ­
- å¯æ‰©å±•åˆ°å…¶ä»–ä¸šåŠ¡åœºæ™¯

**å®æ–½é£é™©:** ğŸŸ¡ **ä½**
- æŠ€æœ¯é£é™©å¯æ§
- å¼€å‘å‘¨æœŸåˆç†
- æœ‰é™çº§æ–¹æ¡ˆ

### é£ä¹¦é›†æˆç‰¹æ®Šä¼˜åŠ¿:

**ğŸ¯ æ— ç¼ä½“éªŒ:**
- æ–‡æ¡£æºå¤´ç›´æ¥æ¥å…¥ï¼Œæ— éœ€å¯¼å‡ºå¯¼å…¥
- æƒé™ä½“ç³»å¤©ç„¶åŒæ­¥ï¼Œå®‰å…¨å¯é 
- ç”¨æˆ·æ— éœ€å­¦ä¹ æ–°å·¥å…·ï¼Œåœ¨é£ä¹¦å†…ç›´æ¥ä½¿ç”¨

**ğŸ”„ å®æ—¶æ€§å¼º:**
- Webhookå®æ—¶ç›‘å¬æ–‡æ¡£å˜æ›´
- å¢é‡æ›´æ–°ï¼Œèµ„æºæ¶ˆè€—ä½
- å›¢é˜Ÿåä½œä¿¡æ¯åŠæ—¶åŒæ­¥

**ğŸ“± ç§»åŠ¨å‹å¥½:**
- é£ä¹¦ç§»åŠ¨ç«¯åŸç”Ÿæ”¯æŒ
- éšæ—¶éšåœ°æŸ¥è¯¢æ–‡æ¡£ä¿¡æ¯
- æ”¯æŒè¯­éŸ³è¾“å…¥å’Œè¯­éŸ³å›å¤

### ä¸‹ä¸€æ­¥è¡ŒåŠ¨å»ºè®®:

1. **é£ä¹¦åº”ç”¨ç”³è¯·:** ç«‹å³åˆ›å»ºä¼ä¸šåº”ç”¨å¹¶ç”³è¯·æƒé™ï¼ˆ3-5å¤©ï¼‰
2. **APIæ¥å£æµ‹è¯•:** éªŒè¯é£ä¹¦æ–‡æ¡£APIå¯ç”¨æ€§ï¼ˆ2å¤©ï¼‰
3. **Einoç¯å¢ƒæ­å»º:** é…ç½®å¼€å‘å’Œæµ‹è¯•ç¯å¢ƒï¼ˆ3å¤©ï¼‰
4. **æ ¸å¿ƒåŠŸèƒ½å¼€å‘:** æŒ‰ç…§å®æ–½è®¡åˆ’å¼€å§‹å¼€å‘ï¼ˆ4å‘¨ï¼‰

**å…³é”®é‡Œç¨‹ç¢‘:**
- **ç¬¬1å‘¨:** é£ä¹¦APIé›†æˆå’Œæƒé™é…ç½®å®Œæˆ
- **ç¬¬2-3å‘¨:** æ–‡æ¡£åŒæ­¥å’Œå‘é‡åŒ–åŠŸèƒ½å¼€å‘  
- **ç¬¬4-5å‘¨:** æ™ºèƒ½é—®ç­”å’Œå®æ—¶æ›´æ–°åŠŸèƒ½
- **ç¬¬6å‘¨:** é£ä¹¦æœºå™¨äººå’Œç”¨æˆ·ç•Œé¢å¼€å‘
- **ç¬¬7-8å‘¨:** æµ‹è¯•ä¼˜åŒ–å’Œä¸Šçº¿éƒ¨ç½²

**é¢„è®¡é¡¹ç›®å¯åŠ¨æ—¶é—´:** 1å‘¨åï¼ˆç­‰å¾…é£ä¹¦æƒé™å®¡æ‰¹ï¼‰
**é¢„è®¡MVPç‰ˆæœ¬ä¸Šçº¿:** 6å‘¨å
**é¢„è®¡å®Œæ•´åŠŸèƒ½ä¸Šçº¿:** 8å‘¨å

---

*è¿™ä¸ªæ–¹æ¡ˆå……åˆ†åˆ©ç”¨äº†Einoæ¡†æ¶çš„ä¼˜åŠ¿ï¼Œæ—¢è§£å†³äº†å®é™…ä¸šåŠ¡ç—›ç‚¹ï¼Œåˆå…·å¤‡è‰¯å¥½çš„æ‰©å±•æ€§ã€‚å»ºè®®ä¼˜å…ˆå¯åŠ¨ï¼* ğŸš€